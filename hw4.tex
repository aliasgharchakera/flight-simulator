\documentclass[addpoints]{exam}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tabularx}

\graphicspath{{images/}}

% Header and footer.
\pagestyle{headandfoot}
\runningheadrule
\runningfootrule
\runningheader{CS 440}{HW 4: Flight Simulator}{Fall 2023}
\runningfooter{}{Page \thepage\ of \numpages}{}
\firstpageheader{}{}{}

\qformat{{\large\bf \thequestion. \thequestiontitle}\hfill}
\boxedpoints

\title{Homework 4: Flight Simulator}
\author{CS 440 Computer Graphics\\Habib University}
\date{Fall 2023}

\begin{document}
\maketitle
\thispagestyle{empty}

In this homework, we build a flight simulator step-by-step. High level instructions are provided and you are expected to use your knowledge of math, computer science, and computer graphics to make reasonable implementation decisions and put the individual pieces together. 

Even though both are equivalent, you are expected to achieve the illusion of flight by varying camera parameters, not by transforming geometry.

The simulator should run in a page named \texttt{simulator.html}.

\begin{questions}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \titledquestion{Plain Terrain}

  A \textit{height map} is commonly used to generate a \textit{terrain mesh}. A height map is a function that takes in 2 values, e.g. longitude and latitude, and generates a height value, $h$. Write a function to generate a height field over a given area in the $xz$- plane. The function would generate a grid in the given area, triangulate it, and randomly perturb the $y$ coordinate of the grid points within $(-2, 2)$.
  \begin{figure}[!h]
    \centering
    \begin{tabular}{cc}
      \includegraphics[height=.35\textwidth]{terrain1}
      & \includegraphics[height=.35\textwidth]{terrain2}\\
      (a) & (b)
    \end{tabular}
    \caption{(a) A triangulated grid in the $xz$- plane. (from \href{http://keithditch.powweb.com/Games/XNA/html/xna\_terrain.html}{Toymaker}) (b) View of an example height field generated by perturbing the $y$- coordinate of the grid points. (from \href{https://www.123rf.com/photo_54102307_stock-vector-3d-wireframe-terrain-contour-vector.html}{123RF})}
  \end{figure}
  
  \noindent\underline{Implementation Tips}
  \begin{itemize}
  \item Write a function \texttt{get\_patch(xmin, xmax, zmin, zmax)} to generate a terrain patch in an appropriate format and return it.
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \titledquestion{Flight}

  Implement a flyby view of your generated terrain. This is the perspective view obtained from a plane flying at a certain altitude (e.g. $y=3$) above your terrain and facing straight ahead, i.e. parallel to ground level. Implement mechanisms to dynamically effect the following.
    \begin{itemize}
    \item alter the bounds of the view, i.e. \textit{left}, \textit{right}, \textit{top}, \textit{bottom}, \textit{near}, and \textit{far} of the viewing volume within reasonable limits. Use the following key map.
      \begin{itemize}
        \item \texttt{1} or \texttt{Shift+1} to vary \textit{left}.
        \item \texttt{2} or \texttt{Shift+2} to vary \textit{right}.
        \item \texttt{3} or \texttt{Shift+3} to vary \textit{top}.
        \item \texttt{4} or \texttt{Shift+4} to vary \textit{bottom}.
        \item \texttt{5} or \texttt{Shift+5} to vary \textit{near}.
        \item \texttt{6} or \texttt{Shift+6} to vary \textit{far}.
      \end{itemize}
    \item quit the simulator. Map the \texttt{Escape} key to quit..
    \end{itemize}

    \noindent\underline{Implementation Tips}
    \begin{itemize}
    \item Modifying a value beyond its allowed constraints should have no effect.
    \end{itemize}
    
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \titledquestion{Varied Terrain}

    Specify a certain height ($y=0$) in your terrain as \textit{ground level}. Your terrain contains greenery at ground level and the points are colored green. Terrain below ground level is covered by water. Only the surface of the water is visible which is colored blue. Terrain above ground level is mountainous and the points are colored green to brown to white as the height increases. Implement mechanisms to dynamically effect the following.
    \begin{itemize}
    \item use the key, \texttt{V}, to toggle the view of the terrain in the following circular order: points, wireframe, and faces.
    \item use the key, \texttt{C}, to toggle the coloring scheme of the terrain in the following circular order: flat, smooth, and Phong.
    \end{itemize}

    \noindent\underline{Implementation Tips}
    \begin{itemize}
    \item The mapping from altitude to color could use the \texttt{map\_point} function from previous assignments.
    \item The points in the \textit{points} view must be large enough to be visible.
    \item To flat shade a polygon, apply the average color of the three vertices.
    \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \titledquestion{Some \href{https://en.wikipedia.org/wiki/Flight_dynamics_(fixed-wing_aircraft)}{Flight Dynamics}}

    \begin{figure}[!h]
    \centering
    \begin{tabular}{cc}
      \includegraphics[height=.35\textwidth]{plane}
      &   \includegraphics[height=.35\textwidth]{view}\\
      (a) & (b)
    \end{tabular}
    \caption{(a) The three rotations of a plane. (from \href{https://en.wikipedia.org/wiki/Flight_dynamics_(fixed-wing_aircraft}{Wikipedia}) (b) An example view of the terrain. Your view need not contain the dashboard.}
    \label{fig:rotate}    
  \end{figure}

  The orientation of a plane in flight is determined by its rotation about three axes. The rotations, termed \textit{pitch}, \textit{roll}, and \textit{yaw}, and the corresponding axes are illustrated in Figure \ref{fig:rotate}. Implement mechanisms to dynamically effect the following.
  \begin{itemize}
  \item each of the indicated rotations, constrained to $(-90^\circ, 90^\circ)$. Use the following key map.
    \begin{itemize}
    \item \texttt{W, S} (or lower case) for pitch
    \item \texttt{A, D} (or lower case) for yaw
    \item \texttt{Q, E} (or lower case) for roll
    \end{itemize}
    Constrain the rotations to $(-90^\circ, 90^\circ)$ and the plane's altitude as appropriate, e.g. $(2.5, 3.5)$.
  \item increase and decrease the speed of the plane between $[0,S]$ where $S$ is a maximum speed of your choosing. Use the \texttt{up} and \texttt{down} arrows to vary speed.
  \end{itemize}

    \noindent\underline{Implementation Tips}
    \begin{itemize}
    \item Modifying a value beyond its allowed constraints should have no effect.
    \item You will have to infer the changes caused by each rotation to the camera's parameters.
    \item The rotation constraints ensure that the plane will never turn so much as to travel backward.
    \item The altitude constraint ensures that the plane will not run aground, nor will it fly up into space.
    \item The plane always sees ahead along its roll axis.
    \item The speed constraint allows for the plane to stand still.
    \end{itemize}

    
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \titledquestion{To Infinity}

    As the terrain is finite, the plane will ultimately fly out of it. Modify your implementation such that a new terrain patch is dynamically computed and added when the plane approaches the boundary of the patch that it is currently flying over. This way, the plane never flies out of terrain.

    \noindent\underline{Implementation Tips}
    \begin{itemize}
    \item You may use the \texttt{get\_patch} function from above.
    \item The more you fly, the more terrain patches will be added and the more your GPU's memory will be consumed, resulting in a slowdown of your simulator.
    \item Make sure to add appropriate patches accounting for the plane's current flight direction. 
    \item Ensure that the plane is never flying over empty terrain, no matter its speed or rotation.
    \item Instead of generating a very large terrain, load a terrain that is large enough for the current view and generate and add new terrain patches based on the plane's motion as it approaches the current boundary.
    \item Instead of unloading patches from GPU memory, you can rewrite already allocated buffers. Making use of the fact that the flight constraints ensure that the plane will not travel backward, figure out how many patches you need to keep in memory at any given time.
    \end{itemize}
\end{questions}
\bigskip
  \centerline{-------------------- \textit{Happy Flying!} --------------------}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
